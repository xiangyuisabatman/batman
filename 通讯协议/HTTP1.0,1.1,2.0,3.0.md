- 1.0/1.1区别
    1. 缓存处理: 在1.0中主要使用header里的if-modified-since, expires来做为缓存判断的标准.1.1则引入了更多的缓存控制策略如Etag,if-unmodified-since,if-match,if-none-match等更多可供选择的缓存头来控制缓存策略
    2. 带宽优化及网络连接的使用: 在1.0中,存在一些浪费带宽的现象,例如客户端只是需要某个对象的一部分,而服务器却将整个对象送过来了,并且不支持断点续传功能,1.1则在请求头引入了range头域,它允许只请求资源的某个部分,即返回码是206(partial content),这样就方便了开发者自由的选择以便于充分利用带宽的连接.
    3. 错误通知的管理: 在1.1中新增了24个错误状态响应码,如409(conflict)标识请求的资源与资源的当前状态发生冲突;410(gone)标识服务器上的某个资源被永久性的删除.
    4. host头处理: 在1.0中认为每台服务器都绑定一个唯一的ip地址,因此,请求消息中的url并没有传递主机名(hostname).但随着虚拟主机技术的发展,在一台物理服务器上可以存在多个虚拟主机,并且它们共享一个ip地址.1.1的请求消息和响应消息都支持host头域,且请求消息中如果没有host头域会报告一个错误(400 bad request).
    5. 长连接: 1.1支持长连接和请求的流水线处理,在一个tcp连接上可以传送多个http请求和响应,减少了建立和关闭连接的消耗和延迟,在1.1中默认开启connection:keep-alive,一定程度上弥补了1.0每次请求都要创建连接的缺点.
- 1.x/2.0区别
    1. 新的二进制格式：1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑2.0的协议解析决定采用二进制格式，实现方便且健壮。
    2. 多路复用，即连接共享：即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面。
    3. header压缩，使用encoder来减少需要传输的header带有大量信息，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减少了需要传输的大小。
    4. 服务端推送：例如请求index.html，同时将main.js返回。而不是请求index.html，再请求main.js。
- 2.0的多路复用和1.0的长连接复用区别
    1. 1.*一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
    2. 1.1 pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
    3. 2.0多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其他连接的正常执行。
    4. 在HTTP/2中,有两个非常重要的概念,分别是帧(frame)和流(stream),帧代表着最小的数据单位,每个帧会标识出该帧属于哪个流,流也就是多个帧组成的数据流，多路复用，就是在一个TCP连接中可以存在多条流。
    5. **队头阻塞**问题可能存在于http层和tcp层，在http1.x时两个层次都存在该问题。HTTP2.0协议的多路复用解决了HTTP层的队头阻塞问题，但是在tcp层仍然存在队头阻塞问题。tcp协议在收到数据包之后，这部分数据可能是乱序到达的，但是tcp必须将所有数据收集排序整合后给上层使用，如果其中某个包丢失了，就必须等待重传，从而出现某个丢包数据阻塞整个连接的数据使用。==**tcp是传输层，http是应用层，http是基于tcp连接基础上的。tcp就是单纯建立连接，不涉及任何我们需要请求的实际数据，简单的传输。http是用来收发数据，即实际应用上来的。**==
- 2.0头部压缩原理
    1. 维护一份相同的静态字典，包含常见的头部名称，以及特别常见的头部名称与值的组合。例如method：GET可以直接用一个字符表示。
    2. 维护一份相同的动态字典，可以动态地添加内容。例如：cookie：xxxxx
    3. 对于不存在静态字典和动态字典的内容，使用哈夫曼编码来减少体积
- 2.0的不足
    1. 建立连接时间长（本质上是tcp的问题）
    2. 队头阻塞问题
    3. 移动互联网领域表现不佳（弱网环境）
- tcp协议的不足和udp的一些优点
    1. 基于tcp开发的设备和协议非常多，兼容困难
    2. tcp协议栈是linux内部的重要部分，修改和升级成本很大
    3. udp本身是无连接的、没有建链和拆链成本
    4. udp的数据包无队头阻塞问题
    5. udp改造成本小
 - HTTP3.0和QUIC协议
    1. QUIC协议就是在UDP基础上具备TCP协议优点的新协议。
    2. HTTP3.0是基于QUIC协议
    3. QUIC协议解决的问题
        1. 队头阻塞：在一条链接上可以有多个流，流与流之间是互不影响的，当一个流出现丢包影响范围非常小，从而解决队头阻塞问题。
        2. 0RTT建链：RTT(数据包一来一回的时间消耗，包括往返传播时延、网络设备内排队时延、应用程序数据处理时延)，HTTPS需要TCP握手和TLS握手，总计需要至少2-3个RTT，普通的HTTP协议也需要至少一个RTT才可以完成握手。QUIC协议在首次连接客户端和服务端会生成密钥(DH算法)，在失效之前非首次连接直接使用密钥进行连接。