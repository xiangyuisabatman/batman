### 原型链
![image](https://camo.githubusercontent.com/ab2b4089cb18f2b79b9d8a1b9c53d930bfd93e55/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31302f352f313636343361353336663438616331323f773d35333026683d32323826663d706e6726733d3139303332)
- 每个实例对象(object)都有`__proto__`私有属性,该属性指向其原型对象(实例原型)(prototype),在调用实例的方法和属性时,如果在实例对象上找不到,就会往原型对象上找
- 构造函数的`prototype`属性也指向实例的原型对象
- 原型对象的`constructor`属性指向构造函数

### 继承
1. 原型链继承
```
// 由于原型链继承共享属性实例属性的缺点，属于引用类型传值，
// 缺点1：引用副本实例属性的修改必然会引起其他副本实例属性的修改，所以不常使用
// 缺点2：不能向父类构造函数随时传递参数，很不灵活
1. 先创建父类实例（方法）
function SuperType() {
    this.property = true;
}
function SubType() {
    this.subproperty = true;
}

2. 改变实例原先的proto转而连接到子类的prototype
SubType.prototype = new SuperType()

3. 子类的prototype的proto改为父类的prototype
```
2. 借用构造函数继承
```
// 借用构造函数继承，在执行Child构造函数的时候，子类的实例各自得到一份构造函数的副本，属于值传递，所以子类之间的属性修改是互不相关的
// 缺点：单独使用无法达到函数复用，因为每一个函数和属性都需要在构造函数中定义，没法复用，即没有父类prototype上的函数，只有不能共用的实例属性。而且instanceof操作无法确定子类实例和父类之间的关系，因为子类的prototype和父类无关
function Parent() {
    this.colors = ['red', 'blue', 'green']
}

function Child() {
    Parent.call(this)
}

let instance = new Child()
```
3. 组合式继承
```
// 常用原型链继承+构造函数继承
// 原型链继承共享属性(属性和方法)，构造函数继承父类构造函数的实例属性
// 缺点：调用了两次父类构造函数，生成了两份实例，一个子类实例，一个父类实例，父类实例作为prototype使用
function Person(name, age) {
    this.name = name
    this.age = age
    this.action = ['speak', 'run', 'eat']
}
Person.prototype.say = function() {
    console.log(`${this.name}${this.age}`)
}
function Student(name, age, score) {
    Person.call(this, name, age) // 借用构造函数，第一次调用父类构造函数
    this.score = score
}

Student.prototype = new Person() // 原型链继承，第二次调用父类构造函数
Student.prototype.constructor = Student // 将实例的原型上的构造函数指定为当前子类的构造函数
Student.prototype.showScore = function() {
    console.log(`${this.score}`)
}
```
4. 原型式继承
```
function extend(Child, Parent) {
    var F = function(){}
    F.prototype = Parent.prototype
    Child.prototype = new F()
    Child.prototype.constructor = Child
}
var person = {
    name: "Nicholas",
    friends: ["Shelby", "Court", "Van"]
};

var anotherPerson = extend(person);
```
5. 寄生式继承
```
// 缺点：原型链继承多个实例的引用类型属性指向相同，存在篡改的可能。无法传递参数
function createAnother(original){
    var clone = object(original); // 通过调用 object() 函数创建一个新对象
    clone.sayHi = function(){  // 以某种方式来增强对象
        alert("hi");
    };
    return clone; // 返回这个对象
}
var person = {
    name: "Nicholas",
    friends: ["Shelby", "Court", "Van"]
};
var anotherPerson = createAnother(person);
anotherPerson.sayHi(); //"hi"
```
6. 寄生组合式继承
```
// 解决了两次调用父类构造函数问题
function Person_1(name, age) {
    this.name = name;
    this.age = age;
    this.action = ['speak', 'run', 'eat'];
    console.log('我被调用了');
}
Person_1.prototype.say = function () {
    console.log(`my name is ${this.name} and I am ${this.age} years old!`);
};

function Student_1(name, age, score) {
    Person_1.call(this, name, age);  // 借用构造函数, 第一次调用父类构造函数
    this.score = score;
}

Student_1.prototype = Object.create(Person_1.prototype);
Student_1.prototype.constructor  = Student_1;
Student_1.prototype.showScore = function () {
    console.log(`my score is ${this.score}`);
};
```